# Malware 1/3

catégorie | points
:---: | :---:
forensic | 100

## 0x0 Intro

>Ce challenge est un challenge en 3 parties indépendantes, mais dont l'ordre logique est indiqué par les numéros : forensics (1) -> pwn (2) -> reverse (3).
>
>/!\ L'image mémoire ci-jointe contient un programme qui a la capacité de chiffrer le fichier /home/%USER%/Desktop/flag.txt /!\
>
>Oh non ! Votre précieux fichier flag.txt présent sur votre bureau semble avoir été chiffré par un programme malveillant... Votre premier réflexe a été d'effectuer une capture mémoire, peut être que le malware tourne encore...
>
>Le flag est au format FCSC{sha256(username:hostname:cmdline)}, où username est le nom de l'utilisateur ayant exécuté le malware, hostname est le nom de la machine sur laquelle celui-ci a été exécuté et cmdline est la ligne de commande complète qui a été exécutée afin de lancer le programme malveillant.

## 0x1 Explication

Le cauchemard de ces dernières années pour les S.I, le cryptomalware.

Notre but est d'extraire les informations demandées afin de forger le flag.

## 0x2 Reconnaissance

Nous avons une capture de la mémoire d'un poste en pièce jointe, donc tout 
simplement nous allons commencer par décompresser l'archive. Sous linux :

```bash
7z e snapshot.sav.7z
```

Notre premier réflexe est de regarder quel genre de fichier nous avons avec 
**file**

```bash
file snapshot.sav
```

Qui nous remonte l'information suivante:

>snapshot.sav: ELF 64-bit LSB core file, x86-64, version 1 (SYSV)

## 0x3 Exploitation

Comme ça, c'est pas super parlant. Le second réflexe est d'essayer d'extraire
les **strings** contenu dans le fichier. Nous allons filtrer que ceux de plus
de 10 caractères afin de nous épargner des lignes inutiles.

```bash
strings -n 10 snapshot.sav > strings.log
```

Puis on regarde ce qui est dans le fichier:

```bash
head -n 25 strings.log
```

Plusieurs informations utile nous arrivent, comme par exemple :

* VBoxDragAndDropSxDragAndDropSvc
* desktop.DBus

Nous sommes sur une capture d'une VM qui tourne sous Linux.

Nous allons donc pouvoir essayer de filtrer le  **hostname** et le **username**,
qui est en fait 2/3 du challenge.

Pour cela, nous allons utiliser grep afin de filtrer les lignes voulues:

Pour le hostname:

```bash
grep "_HOSTNAME" strings.log
```

Ce qui nous donne l'information suivante:

>_HOSTNAME=fcsc2021

Je vous conseille de vous créer un petit fichier indices.txt ou vous stockerez
les informations glannées au fur et à mesure du chall

```bash
grep "_HOSTNAME" strings.log >> indices.txt
```

Une fois l'hostname trouvé, nous allons chercher le username:

```bash
grep "USERNAME" strings.log
```

Nous avons quelques noms qui remontent, mais un en particulier **forensics**

Afin d'en être sur, nous allons rechercher si nous avons une trace de terminal
dans le log.

```bash
grep "@fcsc2020" strings.log
```

C'est confirmé, l'utilisateur est bien forensics. Pour ceux qui comme moi ont
tiqué sur Whoopsie, c'est juste le gestionnaire d'erreurs d'Ubuntu.

Nous pouvons donc ajouter le username dans nos indices:

```bash
echo "USERNAME = forensics" >> indices.txt
```
Mais une autre ligne normalement à du vous interpeller, encore plus si vous
connaissez un peu Linux.

On nous demande de trouver la ligne de commande utilisée pour chiffrer le fichier
et elle est là, en clair !

>forensics@fcsc2021:~/Bureau$  /bin/1 --client -i 192.168.56.103

Pourquoi j'en suis sur ? tout simplement à cause de l'espace avant le /bin
c'est une méthode pour masquer la ligne du fichier .history (comme cela impossible
de la retrouver avec volatility et le plugin linux_bash)

>Pid      Name                 Command Time                   Command
>
>-------- -------------------- ------------------------------ -------
>
>    1799 bash                 2021-03-15 20:34:28 UTC+0000   sudo reboot now
>
>    1799 bash                 2021-03-15 20:34:28 UTC+0000   XDG_SESSION_TYPE=x11
>
>    1799 bash                 2021-03-15 20:34:28 UTC+0000   sudo apt autoremove
>
>    1799 bash                 2021-03-15 20:34:28 UTC+0000   sudo apt update
>
>    1799 bash                 2021-03-15 20:34:28 UTC+0000   suto apt autoremve
>
>    1799 bash                 2021-03-15 20:34:28 UTC+0000   @
>
>    1799 bash                 2021-03-15 20:34:28 UTC+0000   sudo apt upgrade
>
>    1799 bash                 2021-03-15 20:34:28 UTC+0000   sudo apt dist-upgrade
>
>    1799 bash                 2021-03-15 20:34:28 UTC+0000   sudo apt autoremove
>
>    1799 bash                 2021-03-15 20:34:28 UTC+0000   sudo apt dist-upgrade
>
>    1799 bash                 2021-03-15 20:34:28 UTC+0000   sudo apt update
>
>    1799 bash                 2021-03-15 20:34:28 UTC+0000   sudo apt upgrade
>
>    1799 bash                 2021-03-15 20:34:28 UTC+0000   sudo apt install gcc make perl openssl-dev
>
>    1799 bash                 2021-03-15 20:34:28 UTC+0000   sudo apt install gcc make perl libssl-dev
>

Ce qui mets aussi la puce à l'oreille, c'est le paramètre --client, cela fait
penser à la connexion au C2C (Centre de Commande), le gestionnaire du ransomware.

On ajoute donc la ligne aux indices:

```bash
echo "  /bin/1 --client -i 192.168.56.103" >> indices.txt
```

Voilà, désormais, nous pouvons commencer la création du flag:

>echo -n "forensics:fcsc2021: /bin/1 --client -i 192.168.56.103" | sha256sum

Un grand merci à \J de m'avoir pointé l'erreur du echo -e à remplacer par -n.

En effet, par défaut, echo envoi un null terminator (**\n**) à la fin de son 
affichage, ce qui va modifier l'output (vous pouvez le voir avec man echo).

Le flag final est donc:

>FSCS{9245ba7fc13d23e6323c7c016b3444c4ada8c1429e4e96a7dfef52a654e6bd2b}

## 0x4 TL;DR

Dans ce challenge, comparé à l'année dernière, l'utilisation de volatility
n'était pas nécessaire.

Une recherche de strings nous à permis de retrouver l'**HOSTNAME** puis par
déduction le **USERNAME** puis **le cryptolocker** et ses paramètres.

Le hashage des informations au format **SHA256** était la réponse.

## 0x5 Bonus

Je me suis forcé à créer un profil volatility pour jouer un peu avec, les 
informations nécessaires sont dans le fichier indices.md et j'ai suivi le 
[tuto suivant](https://www.andreafortuna.org/2019/08/22/how-to-generate-a-volatility-profile-for-a-linux-system/)
afin de générer mon profil.
